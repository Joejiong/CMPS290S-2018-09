This paper covers linearizability as a correctness condition for concurrent objects which are defined as objects that can be manipulated or used by multiple concurrent processes. They define a linearizable operation as one that is “equivalent” to a legally sequential computation. Unlike serializability, linearizability is defined as a local property where each operation must be linearizable. Although I am still not sure what the difference is. So therefore scheduling can be performed in a decentralized manner. I assume that then serializability must have some centralized component. It is also non blocking so therefore an object does not have to wait. They present two sorts of problems one is reasoning about the correctness of linearizable object implementations and the other is reasoning about computations on linearizable objects by transforming assertions into equivalent ones about sequential computations. Two requirements are presented for concurrent objects, each operation taking place instantaneously and also that nonconcurrent operations are preserved. I am not too sure what exactly they mean in this statement by “preserved”. A few examples built on a FIFO queue are given in order to better explain the requirements in a rather intuitive manner. The paper models the execution of concurrent systems with histories, “finite sequences of invocations and responses”. A history is said to be sequential if the first event is an invocation and that each invocation is immediately followed by a response. If these conditions are not met then the history is said to be concurrent. An operation is described as a pair of events, an invocation and a response. This all builds towards an overall definition of linearizability. If a history H can be extended to some history H` so that complete(H`) is equivalent to some sequential history S and that <H is a subset of <S. After this definition we get a brief revisit to the queue example given earlier in the section. After that we go into the properties of linearizability which includes locality and non-blocking behavior. They present comparison to sequential consistency (which is not local and weaker as it does not require preservation of ordering precedence), serializability (also not local, and inherently blocking). In the last two sections the authors present their method for verifying the linearizability of implementations and reason about the properties of objects given that they are linearizable.

One thing that I learned while reading this paper is the actual difference between linearizability, sequential consistency, and serializability. Before now I assumed that they were the same thing. One thing I didn’t quite understand is how linearizability is applied to system design. This is a very theory and proof heavy paper so I ended up lost at times in the technical details. What I am still wondering is what implications does linearizability have for system design and what specific benefits does it bring to the table when building a distributed system? A concrete step towards answering this question is to read what more implementation and experiment focused papers cite this one to see if they leverage this paper’s formalized view of linearizability.
