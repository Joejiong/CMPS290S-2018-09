This paper deals with the difficulty in reliably implementing fault-tolerant distributed algorithms. Much in the theme of the course, the authors present what they call Psync, a domain specific language that is used to represent an asynchronous system as a synchronous one that drops messages in order to emulate network faults. I find the statement concerning consensus algorithms being central to high availability systems a bit odd considering the large number of papers we read that avoid consensus algorithms. The introduction of the paper seems to pitch psync as a magic bullet, possibility of automatic verification, efficient, high level, etc. Psync is built off of the “heard-of” model which, as described by the paper, organizes algorithms into “communication closed rounds” with the program being a sequence of these rounds. Communication closed meaning that all the messages are either delivered in that round or dropped. A rather nifty clear scope for messages that seem somewhat like timeouts. The nodes of the system are in an adversarial environment. Each one having a heard of set which is the set of nodes one has “heard from”. I am not entirely sure how to word it. The way it is explained in the paper is more understandable. Psync is implemented in scala. Also Psync allows for automatic verification. If I am understanding it correctly the runtime for Psync translates the synchronous program into an asynchronous one that is actually run in scala. The two being provably indistinguishable from one another. They use this language to implement a few algorithms including the LastVoting consensus algorithm. The program size is rather small. Three implementations of paxos are compared to the Psync lastvoting implementation. Against which Psync performs ok, sort of middle of the road.


I have started to fatigue a bit of these sort of papers but the mention of fault tolerance caused me to perk up. What I did not understand in this paper is the massive number of theorems and proofs that get thrown at the reader. It will take me some time to sift through those. What I did learn though is what the heard-of model is. That is a concept that was been foreign to me. My research question is whether there is anything to be learned from this paper that can be carried over to some other work I have been reading about in domain specific languages for cryptographic algorithms. Which is another realm of difficult to implement programs.
