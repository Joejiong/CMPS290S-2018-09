This paper  presents a new embedded language called MixT (how does one pronounce that?) which allows for mixed language transactions. MixT provides information flow checking at compile time, which strangely wasn’t mentioned in previous papers about multiple consistency models coexisting even though they have a lot in common. The mixed consistency transactions maintain consistency models for individual pieces of data and are atomic. In addition to this MixT is built to handle a non-homogeneous environment which is not something we have seen explicitly stated so far in this class. The way that MixT expresses data integrity as a form of labels on types reminds me of methods used in security focused information flow control. In addition to compile time information flow control MixT also performs information flow analysis to divide up transactions while preserving atomicity. Unlike the previous paper this one actually gives us semantics and syntax rules in figures (much easier to read). I am having flashbacks to noninterference proofs from the computer security class. Now those shall also haunt my dreams alongside consistency models. The transaction splitting works by denoting different phases in which the treatment of loops is tricky. Providing transaction atomicity as a whole will in some cases be easy but when a transaction has to write to multiple atomic stores at the same time one must use something called a write witness and a commit witness. As with previous paper we see a concept of endorsement which becomes a bit more complicated than before due to splitting up transactions. This is solved by adding more witnesses, this time for reads, and a read only phase. Unlike many of the programming languages papers I have seen this is not in Scala or Haskell but instead in C++ and was tested using different backing stores based on PostgreSQL. Also they have done optimizations! The systems person in me is now happy.

What I learned from this paper is a different application other than security for information flow. I didn’t really not understand anything in this paper. It all seemed pretty straightforward. That said I am still working through the semantics and will have to stare at that a bit longer to fully understand it. My research level question for this paper concerns the treatment of consistency as a kind of data integrity. As data integrity is one of the important aspects of security do the ideas presented in this paper implicitly provide some sort of security guarantee as well? A concrete step towards answering this question would be to dig up some of the papers I read when taking Arden’s computer security class and comparing MixT with one of the many information flow security papers. I am interested in this as many distributed systems papers ignore security altogether which makes them hard to implement and use in an industry environment (not really, but I sometimes like to pretend industry actually cares enough).

Edit: I actually didn't notice this until now but one of the contributing reasons to my flashbacks to information flow applied to security is probably related to the authors.
