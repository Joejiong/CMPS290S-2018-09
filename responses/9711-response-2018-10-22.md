This paper is by the same authors as the previous paper and would appear to be be a prior formal description of conflict free replicated data types (this paper was from January 2011 versus the other one from July). This paper start off by doing a better job of describing eventual consistency and easing the reader into the problems that CRDTs claim to solve as opposed to the previous paper that we read. The authors claim that previous attempts at implementing eventual consistency are “brittle and error prone”. They start describing a CRDT through the example of a simple replicated counter where the operations are all commutative. One of the big advantages being that they converge to a common state and require no synchronization. This paper takes to form of a sort of survey of existing CRDT designs at the time of publication and to formalize some of the principles of a CRDT. They claim that the garbage collection that is needed to prevent unbounded growth is not entirely needed but is instead an optional performance optimization. They first start building a system model for CRDTs, starting with the concept of atoms and objects. Atoms being familiar basic data types and objects being mutable replicated data. Operations can be performed on an object which in turn can contain atoms along with an initial state and some concept of an identity (a unique name for the object?). They present the now familiar ides of state based and object based methods for distributing information about operations to each of the replicas in a set. Complete with pictures, examples, and formal definitions this time. The authors give a formalized definition for what they mean by convergence between two objects for both state and object based CRDTs. Along with giving a few examples of real world application for each type. They even give some sort of pseudo-code for implementing them. They provide a few examples of CRDTs most of which are relatively simple things like counters, registers, graphs, etc. Which could all be used to create more complex systems. The cooperative text editing example being the most interesting of the bunch. They present a short section on garbage collection in order to keep CRDTs performant over time. I wish they had some sort of results about the instability of CRDTs.  Is there a specific time frame based on the implementation that can model how long until they become too inefficient to use without garbage collection? In the end how bad does the garbage problem actually get? Really I see the challenge of unsynchronized garbage collection as an interesting topic. Lastly the paper goes into a few stronger examples of CRDTs. Those examples being a shopping cart and a e-commerce bookstore.

The primary thing I don’t quite understand is why we read this paper second. I feel as if I understand the previous CRDT paper a bit better after reading this one. I am possessed by the desire to implement all of this pseudocode and benchmark it. The biggest thing I learned is actually how to use a CRDT. Formal definitions are great but there has to be an in between step between them and an actual implementation. Just a wonderful paper as a reference for systems engineers. Also free of claims pertaining to certain impossibility proofs.
