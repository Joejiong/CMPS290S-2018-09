This paper presents Bloom which is a distributed programming language that assists the programmer in  managing the consistency, availability, and latency tradeoffs through something called the CALM principle. The paper makes the argument that ACID transactions are too costly in low latency/high availability applications and that there are very few software development tools that assist the programmer in writing weakly consistent systems. The paper first introduces the CALM principle. I rather like the term temporal nondeterminism as it neatly wraps up problems with delaying and reordering messages. The authors tie this nondeterminism and order independence to the nature of set-based declarative languages. This leads into the distinction between monotonic and non-monotonic programs. Where the monotonic programs are easy to distribute across a network. With this they draw the relationship between Consistency And Logical Monotonicity where a monotonic program will guarantee eventual consistency. So the challenge becomes creating programming language checks for monotonicity. Where monotonicity cannot be be guaranteed the authors provide a way to pinpoint the parts of the system in which coordination may be required. They call these points of order. Although it is still ideal to minimize where coordination is required. In bloom state is presented as unordered sets, and relies on declarative logic. It is based on a temporal logic called Dedalus. The early form of Bloom is rather amusingly called BUD and is written as a domain specific adaptation of the Ruby programming language. A program in Bloom is described as a series of declarative statements and facts or tuples. Where statements can only reference an element that is local to a node. State is maintained by a series of collection types that are constructed like relational schema. With this the authors implement a basic key-value store using BUD. Interestingly they provide the entire source code for each component of the key-value store (abstract, single-node, and replicated) in the paper itself. Which speaks volumes about the brevity of BUD as a language. After this they also implement a basic shopping cart. First talking about “destructive” updates to the shopping cart. Then introducing their “disorderly” shopping cart. They run into familiar problems with requiring coordination in order to properly delete updates from the cart which is a problem that reappears again and again in distributed systems literature.

I didn’t learn much that was new from this paper as I had read it before for Peter’s distributed systems class. So really it was more reinforcement of already learned material. It is rather nice that the paper includes a legend for their figures. Which makes them a lot more readable. I understand most of the paper but I am still a bit iffy on declarative programming in general but it is getting better the more I look at papers discussing it.
