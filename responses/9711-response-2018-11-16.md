This paper builds upon previous work on Bloom and the CALM theorem that was presented on wednesday. The authors extend bloom into something they call bloom^L (why do people like to use exponentiation in names, how does one pronounce it?) which adds support for lattices and enables a CALM analysis on arbitrary lattices in programs. Unlike the previous paper this one does mention work on CRDTs (I can’t remember the time frame for first one). The authors point out one of the major issues in CRDTs. Which is the complexity involved with non-trivial modules. Although the monotonic logic also presented in this paper describes a type dilemma. Both of these problems form the motivation for bloom^L. The advantages of bloom^l over bloom are, CALM analysis over arbitrary lattices, mapping morphisms and monotone functions, and an extension to the evaluation scheme to support lattices. In the new language both lattices and collections can represent the program state where an element in a lattice is a specific collection. Statements are more or less the same but with new constraints when using lattices. There is no delete and no direct asynchronous communication support. The language also allows for computing values over a lattice via methods, some of which can be non-monotonic. There is a set of built in lattices included with bloom. As with many computer science papers I must criticize the lack of benchmarks to establish whether or not something is good. Although for the purposes of the experiment on evaluating the transitive closure of a graph, the results are clear enough. Similarly to the previous Bloom paper this one also implements a key value store as a case study. Which is still just as concise as the regular bloom version. The authors also implement a basic shopping cart much like the original bloom paper. I appreciate the similarity in the case studies as I can compare bloom and bloom^L implementations.

Much like the last paper I have read this one before in Peter’s distributed systems class. So I didn’t quite learn anything new. Although a few things from the previous paper that were not clear to me now are. Mostly this has to do with my lack of knowledge surrounding lattices. I am still iffy on material such as monotone functions and morphisms although that is likely due to me forgetting it right after the first time I read this paper. My research question is how easy is this language to use? From what I understand it assumes some knowledge of more abstract concepts to use. The easiest way to explore this question would be to implement some other data structure than what was presented in the paper and see how “hard” it is. The issue being that “difficulty” isn’t really measurable. 
