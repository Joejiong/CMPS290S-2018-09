This paper attempts to tackle the issue of vague and irregular relaxed consistency models (I would assume this includes everything weaker than linearizability). To solve this problem the authors propose a new programming model that like many programming language papers explicitly define certain properties that are advantageous to the problem as well as a type system.  This paper does make more references that most I have encountered. This is not a complaint, just an observation. They more specifically characterize the problem they wish to solve as undisciplined use of data leads to inadvertently weaker consistency. The authors present a storage system that they call IPA(Inconsistent, performance-bound, approximate). This storage system has the property of consistency safety, which to me appears to be a form of information flow control although instead of confidentiality or integrity they are dealing with consistency. Also presented are consistency types that allow a typing system to be applied to consistency levels. Lastly it presents something called error-bound consistency where numeric error bounds are applied on returned values. They use a strange example involving tickets to a star wars movie to make a case for consistency safety as a valuable property. The programming model applies consistency policies to operations on abstract data types which in tern gives us a consistency type for the result of said operations. They present the lattice of consistency types which include consistent, interval, localquorum, rushed, and inconsistent. An endorse operation is described as an upcast. I am somewhat stumped on how exactly the rushed operation works. The interval type shows an interval of values in which the true strong consistent value is contained. One can enforce a consistency policy through either static, latency, or error bounds. The authors built IPA as a client side library. It would not be a distributed systems/programming languages paper if the implementation was not done with a distributed datastore (cassandra) or a functional programming language (scala). One nice touch in this paper is a set of network conditions that were present for the experiments. I don’t often see that included. They present a very simple counter based benchmark (with error bars) to demonstrate the latency in different environments. Also they show performance for their previously presented ticket service along with what they call a “twitter clone”. While the paper does present the results well I am not entirely sure whether or not the results are good as they don’t give any outside program to compare it to. This is not a complaint specific to this paper but for computer science papers in general.

My key takeaway from this paper is the idea of consistency safety, which as I stated earlier reminds me of information flow control in security. I find it helps make sense out of programming with different consistency models at play simultaneously. What I did not so much understand was the concept of error bound consistency or of the rushed consistency type but that may be solved through a presentation on the topic and reading through the paper a second time. My primary research question involves whether or not the idea of consistency types could be applied to other replicated data types. I am eternally frustrated by trying to implement CRDTs and am grasping at any possibility of making it easier.
