This paper  presents something called Causal Memory (still reading this as casual) that is a weaker guarantee for consistency in a shared memory distributed system with the goal of lowering latencies that provide a significant barrier to scalability. It weakens the guarantees by making it so that processes only have to agree on the ordering of operations that are causally related to one another. This is considered weakly consistent when compared to atomic (they mention this is linearizable, related to the previous paper?) or sequentially consistent memory schemes. It is stated that the author’s version of causal memory is related to Lamport’s work in potential causality. They liken the concept of causal memory to causally ordered messages and similarly this implementation utilizes vector clock timestamps. Both are non blocking. They define specific semantics for overwrites and queuing. They do not prevent hidden writes and they guarantee that all messages will eventually be received by the recipient (would it be more beneficial to prevent hidden hidden writes?). The shared memory systems section describes histories very similarly to the linearizability paper. Other than sequential consistency they also look at something called pipelined RAM or PRAM. Causal memory is presented as something somewhat in between sequential consistency and PRAM on a sort of consistency strength spectrum (easier for me to visualize instead of that messy flow chart). Causal memory describes operations with regards to a “writes-into” order which then induces a causality order. The example shown in figure two is not all that clear.  From there the authors describe a basic implementation of causal memory for a given process that to my dismay was only pseudo code. Although it prove sufficient to prove a series of lemmas pertaining to the implementation. The last section covers actually writing programs using causal memory. They establish two classes of programs where is one writes them to run correctly with sequentially consistent memory then they will work with causal memory (hopefully faster?). They still don’t give any hard evidence that it will run faster. The fact that causal memory is more efficient is clear, but I am not wholly convinced without hard numbers.

Overall causal consistency is a relatively logical conclusion to reach while developing a piece of software in a more ad hoc manner (I have somewhat done it before in a sloppy manner while writing multithreaded programs). I would say my big takeaway in terms of new knowledge from this paper would be a more formalized way to approach those situation. Which would probably help with how my multithreaded programs are often unstable. One thing that did disappoint me is the rather incomplete nature of their implementation. How do we know for sure that it will provide better latency and scalability without experimental results? This leads into my research question being has anyone implemented causal memory in a working system? A concrete step that one can take towards this is to build a basic messaging system with something like python using the pseudo code provided by the authors and comparing that to a system using atomic (linearizable) or sequential consistency. In fact that may make a good blog post. 
